#+TITLE: Identification of the Stewart Platform using Simscape
:DRAWER:
#+STARTUP: overview

#+LANGUAGE: en
#+EMAIL: dehaeze.thomas@gmail.com
#+AUTHOR: Dehaeze Thomas

#+HTML_LINK_HOME: ./index.html
#+HTML_LINK_UP: ./index.html

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="./css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="./css/readtheorg.css"/>
#+HTML_HEAD: <script src="./js/jquery.min.js"></script>
#+HTML_HEAD: <script src="./js/bootstrap.min.js"></script>
#+HTML_HEAD: <script src="./js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <script src="./js/readtheorg.js"></script>

#+PROPERTY: header-args:matlab  :session *MATLAB*
#+PROPERTY: header-args:matlab+ :comments org
#+PROPERTY: header-args:matlab+ :exports both
#+PROPERTY: header-args:matlab+ :results none
#+PROPERTY: header-args:matlab+ :eval no-export
#+PROPERTY: header-args:matlab+ :noweb yes
#+PROPERTY: header-args:matlab+ :mkdirp yes
#+PROPERTY: header-args:matlab+ :output-dir figs

#+PROPERTY: header-args:latex  :headers '("\\usepackage{tikz}" "\\usepackage{import}" "\\import{$HOME/Cloud/thesis/latex/}{config.tex}")
#+PROPERTY: header-args:latex+ :imagemagick t :fit yes
#+PROPERTY: header-args:latex+ :iminoptions -scale 100% -density 150
#+PROPERTY: header-args:latex+ :imoutoptions -quality 100
#+PROPERTY: header-args:latex+ :results file raw replace
#+PROPERTY: header-args:latex+ :buffer no
#+PROPERTY: header-args:latex+ :eval no-export
#+PROPERTY: header-args:latex+ :exports results
#+PROPERTY: header-args:latex+ :mkdirp yes
#+PROPERTY: header-args:latex+ :output-dir figs
#+PROPERTY: header-args:latex+ :post pdf2svg(file=*this*, ext="png")
:END:

* Introduction                                                        :ignore:

* Modal Analysis of the Stewart Platform
** Introduction                                                      :ignore:
** Matlab Init                                              :noexport:ignore:
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
  <<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
  <<matlab-init>>
#+end_src

#+begin_src matlab :results none :exports none
  simulinkproject('../');
#+end_src

#+begin_src matlab
  open('stewart_platform_model.slx')
#+end_src

** Initialize the Stewart Platform
#+begin_src matlab
  stewart = initializeStewartPlatform();
  stewart = initializeFramesPositions(stewart);
  stewart = generateGeneralConfiguration(stewart);
  stewart = computeJointsPose(stewart);
  stewart = initializeStrutDynamics(stewart);
  stewart = initializeJointDynamics(stewart, 'type_F', 'universal_p', 'type_M', 'spherical_p');
  stewart = initializeCylindricalPlatforms(stewart);
  stewart = initializeCylindricalStruts(stewart);
  stewart = computeJacobian(stewart);
  stewart = initializeStewartPose(stewart);
  stewart = initializeInertialSensor(stewart);
#+end_src

#+begin_src matlab
  ground = initializeGround('type', 'none');
  payload = initializePayload('type', 'none');
#+end_src

** Identification
#+begin_src matlab
  %% Options for Linearized
  options = linearizeOptions;
  options.SampleTime = 0;

  %% Name of the Simulink File
  mdl = 'stewart_platform_model';

  %% Input/Output definition
  clear io; io_i = 1;
  io(io_i) = linio([mdl, '/Controller'],              1, 'openinput');  io_i = io_i + 1; % Actuator Force Inputs [N]
  io(io_i) = linio([mdl, '/Relative Motion Sensor'],  1, 'openoutput'); io_i = io_i + 1; % Position/Orientation of {B} w.r.t. {A}
  io(io_i) = linio([mdl, '/Relative Motion Sensor'],  2, 'openoutput'); io_i = io_i + 1; % Velocity of {B} w.r.t. {A}

  %% Run the linearization
  G = linearize(mdl, io);
  % G.InputName  = {'tau1', 'tau2', 'tau3', 'tau4', 'tau5', 'tau6'};
  % G.OutputName = {'Xdx', 'Xdy', 'Xdz', 'Xrx', 'Xry', 'Xrz', 'Vdx', 'Vdy', 'Vdz', 'Vrx', 'Vry', 'Vrz'};
#+end_src

Let's check the size of =G=:
#+begin_src matlab :results replace output
  size(G)
#+end_src

#+RESULTS:
: size(G)
: State-space model with 12 outputs, 6 inputs, and 18 states.
: 'org_babel_eoe'
: ans =
:     'org_babel_eoe'

We expect to have only 12 states (corresponding to the 6dof of the mobile platform).
#+begin_src matlab :results replace output
  Gm = minreal(G);
#+end_src

#+RESULTS:
: Gm = minreal(G);
: 6 states removed.

And indeed, we obtain 12 states.

** Coordinate transformation
We can perform the following transformation using the =ss2ss= command.
#+begin_src matlab
  Gt = ss2ss(Gm, Gm.C);
#+end_src

Then, the =C= matrix of =Gt= is the unity matrix which means that the states of the state space model are equal to the measurements $\bm{Y}$.

The measurements are the 6 displacement and 6 velocities of mobile platform with respect to $\{B\}$.

We could perform the transformation by hand:
#+begin_src matlab
  At = Gm.C*Gm.A*pinv(Gm.C);

  Bt = Gm.C*Gm.B;

  Ct = eye(12);
  Dt = zeros(12, 6);

  Gt = ss(At, Bt, Ct, Dt);
#+end_src

** Analysis
#+begin_src matlab
  [V,D] = eig(Gt.A);
#+end_src

#+begin_src matlab :exports results :results value table replace :tangle no :post addhdr(*this*)
  ws = imag(diag(D))/2/pi;
  [ws,I] = sort(ws)

  xi = 100*real(diag(D))./imag(diag(D));
  xi = xi(I);

  data2orgtable([[1:length(ws(ws>0))]', ws(ws>0), xi(xi>0)], {}, {'Mode Number', 'Resonance Frequency [Hz]', 'Damping Ratio [%]'}, ' %.1f ');
#+end_src

#+RESULTS:
| Mode Number | Resonance Frequency [Hz] | Damping Ratio [%] |
|-------------+--------------------------+-------------------|
|         1.0 |                    780.6 |               0.4 |
|         2.0 |                    780.6 |               0.3 |
|         3.0 |                    903.9 |               0.3 |
|         4.0 |                   1061.4 |               0.3 |
|         5.0 |                   1061.4 |               0.2 |
|         6.0 |                   1269.6 |               0.2 |

** Visualizing the modes
To visualize the i'th mode, we may excite the system using the inputs $U_i$ such that $B U_i$ is co-linear to $\xi_i$ (the mode we want to excite).

\[ U(t) = e^{\alpha t} (  ) \]

Let's first sort the modes and just take the modes corresponding to a eigenvalue with a positive imaginary part.
#+begin_src matlab
  ws = imag(diag(D));
  [ws,I] = sort(ws)
  ws = ws(7:end); I = I(7:end);
#+end_src

#+begin_src matlab
  for i = 1:length(ws)
#+end_src

#+begin_src matlab
  i_mode = I(i); % the argument is the i'th mode
#+end_src

#+begin_src matlab
  lambda_i = D(i_mode, i_mode);
  xi_i = V(:,i_mode);

  a_i = real(lambda_i);
  b_i = imag(lambda_i);
#+end_src

Let do 10 periods of the mode.
#+begin_src matlab
  t = linspace(0, 10/(imag(lambda_i)/2/pi), 1000);
  U_i = pinv(Gt.B) * real(xi_i * lambda_i * (cos(b_i * t) + 1i*sin(b_i * t)));
#+end_src

#+begin_src matlab
  U = timeseries(U_i, t);
#+end_src

Simulation:
#+begin_src matlab
  load('mat/conf_simscape.mat');
  set_param(conf_simscape, 'StopTime', num2str(t(end)));
  sim(mdl);
#+end_src

Save the movie of the mode shape.
#+begin_src matlab
  smwritevideo(mdl, sprintf('figs/mode%i', i), ...
               'PlaybackSpeedRatio', 1/(b_i/2/pi), ...
               'FrameRate', 30, ...
               'FrameSize', [800, 400]);
#+end_src

#+begin_src matlab
  end
#+end_src

#+name: fig:mode1
#+caption: Identified mode - 1
[[file:figs/mode1.gif]]

#+name: fig:mode3
#+caption: Identified mode - 3
[[file:figs/mode3.gif]]

#+name: fig:mode5
#+caption: Identified mode - 5
[[file:figs/mode5.gif]]

