<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-08-05 mer. 13:27 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>Kinematic Study of the Stewart Platform</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Dehaeze Thomas" />
<link rel="stylesheet" type="text/css" href="./css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="./css/readtheorg.css"/>
<script src="./js/jquery.min.js"></script>
<script src="./js/bootstrap.min.js"></script>
<script src="./js/jquery.stickytableheaders.min.js"></script>
<script src="./js/readtheorg.js"></script>
<script>MathJax = {
          tex: {
            tags: 'ams',
            macros: {bm: ["\\boldsymbol{#1}",1],}
            }
          };
          </script>
          <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./index.html"> UP </a>
 |
 <a accesskey="H" href="./index.html"> HOME </a>
</div><div id="content">
<h1 class="title">Kinematic Study of the Stewart Platform</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org6858f1f">1. Jacobian Analysis</a>
<ul>
<li><a href="#org8210cee">1.1. Jacobian Computation</a></li>
<li><a href="#org4d71022">1.2. Jacobian - Velocity loop closure</a></li>
<li><a href="#org2847e30">1.3. Jacobian - Static Force Transformation</a></li>
</ul>
</li>
<li><a href="#org87bfd11">2. Stiffness Analysis</a>
<ul>
<li><a href="#orgb1956e6">2.1. Computation of the Stiffness and Compliance Matrix</a></li>
</ul>
</li>
<li><a href="#org5718735">3. Forward and Inverse Kinematics</a>
<ul>
<li><a href="#orgebda1d9">3.1. Inverse Kinematics</a></li>
<li><a href="#org1795522">3.2. Forward Kinematics</a></li>
<li><a href="#org5a3ce80">3.3. Approximate solution of the Forward and Inverse Kinematic problem for small displacement using the Jacobian matrix</a></li>
</ul>
</li>
<li><a href="#org86b4b35">4. Estimation of the range validity of the approximate inverse kinematics</a>
<ul>
<li><a href="#orga78aa66">4.1. Stewart architecture definition</a></li>
<li><a href="#orgd83ccf3">4.2. Comparison for &ldquo;pure&rdquo; translations</a></li>
<li><a href="#org4871c83">4.3. Conclusion</a></li>
</ul>
</li>
<li><a href="#org63255f9">5. Estimated required actuator stroke from specified platform mobility</a>
<ul>
<li><a href="#orgadaa219">5.1. Stewart architecture definition</a></li>
<li><a href="#orgde50dd3">5.2. Wanted translations and rotations</a></li>
<li><a href="#org24e45ca">5.3. Needed stroke for &ldquo;pure&rdquo; rotations or translations</a></li>
<li><a href="#orgf6ba90c">5.4. Needed stroke for &ldquo;combined&rdquo; rotations or translations</a></li>
</ul>
</li>
<li><a href="#orgbbbf7b3">6. Estimated platform mobility from specified actuator stroke</a>
<ul>
<li><a href="#org6a6a5df">6.1. Stewart architecture definition</a></li>
<li><a href="#org2c6819e">6.2. Pure translations</a></li>
</ul>
</li>
<li><a href="#orgad495dd">7. Estimation of the Joint required Stroke</a>
<ul>
<li><a href="#orgae20178">7.1. Example of the initialization of a Stewart Platform</a></li>
</ul>
</li>
<li><a href="#orgc4916dc">8. Functions</a>
<ul>
<li><a href="#org26e8b28">8.1. <code>computeJacobian</code>: Compute the Jacobian Matrix</a>
<ul>
<li><a href="#orgcde905e">Function description</a></li>
<li><a href="#org5be121e">Check the <code>stewart</code> structure elements</a></li>
<li><a href="#org0cd57b5">Compute Jacobian Matrix</a></li>
<li><a href="#orge21dcfc">Compute Stiffness Matrix</a></li>
<li><a href="#orgae76071">Compute Compliance Matrix</a></li>
<li><a href="#org78f18d7">Populate the <code>stewart</code> structure</a></li>
</ul>
</li>
<li><a href="#orgb82066f">8.2. <code>inverseKinematics</code>: Compute Inverse Kinematics</a>
<ul>
<li><a href="#org89930b7">Theory</a></li>
<li><a href="#orgb66d0e9">Function description</a></li>
<li><a href="#org0aeb7ad">Optional Parameters</a></li>
<li><a href="#orga54645b">Check the <code>stewart</code> structure elements</a></li>
<li><a href="#org0d64c23">Compute</a></li>
</ul>
</li>
<li><a href="#orgf5d8f0b">8.3. <code>forwardKinematicsApprox</code>: Compute the Approximate Forward Kinematics</a>
<ul>
<li><a href="#orgc074bc3">Function description</a></li>
<li><a href="#org9a855b1">Optional Parameters</a></li>
<li><a href="#orgdc0187a">Check the <code>stewart</code> structure elements</a></li>
<li><a href="#orge5ade24">Computation</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<p>
The kinematic analysis of a parallel manipulator is well described in (<a href="#citeproc_bib_item_1">Taghirad 2013</a>):
</p>
<blockquote>
<p>
Kinematic analysis refers to the study of the geometry of motion of a robot, without considering the forces an torques that cause the motion.
In this analysis, the relation between the geometrical parameters of the manipulator with the final motion of the moving platform is derived and analyzed.
</p>
</blockquote>

<p>
The current document is divided in the following sections:
</p>
<ul class="org-ul">
<li>Section <a href="#orgc45d118">1</a>: The Jacobian matrix is derived from the geometry of the Stewart platform. Then it is shown that the Jacobian can link velocities and forces present in the system, and thus this matrix can be very useful for both analysis and control of the Stewart platform.</li>
<li>Section <a href="#orgf9e4f1a">2</a>: The stiffness and compliance matrices are derived from the Jacobian matrix and the stiffness of each strut.</li>
<li>Section <a href="#orgca82bb8">3</a>: The Forward and Inverse kinematic problems are presented.</li>
<li>Section <a href="#org7d1d866">4</a>: The approximate solution of the Inverse kinematic problem is compared with the exact solution in order to determine the validity of the approximation.</li>
<li>Section <a href="#org1f540fa">5</a>: The Inverse kinematic solution is used to estimate required actuator stroke from the wanted mobility of the Stewart platform.</li>
</ul>

<div id="outline-container-org6858f1f" class="outline-2">
<h2 id="org6858f1f"><span class="section-number-2">1</span> Jacobian Analysis</h2>
<div class="outline-text-2" id="text-1">
<p>
<a id="orgc45d118"></a>
</p>
<p>
From (<a href="#citeproc_bib_item_1">Taghirad 2013</a>):
</p>
<blockquote>
<p>
The Jacobian matrix not only reveals the <b>relation between the joint variable velocities of a parallel manipulator to the moving platform linear and angular velocities</b>, it also constructs the transformation needed to find the <b>actuator forces from the forces and moments acting on the moving platform</b>.
</p>
</blockquote>
</div>
<div id="outline-container-org8210cee" class="outline-3">
<h3 id="org8210cee"><span class="section-number-3">1.1</span> Jacobian Computation</h3>
<div class="outline-text-3" id="text-1-1">
<p>
If we note:
</p>
<ul class="org-ul">
<li>\({}^A\hat{\bm{s}}_i\) the unit vector representing the direction of the i&rsquo;th strut and expressed in frame \(\{A\}\)</li>
<li>\({}^A\bm{b}_i\) the position vector of the i&rsquo;th joint fixed to the mobile platform and expressed in frame \(\{A\}\)</li>
</ul>

<p>
Then, we can compute the Jacobian with the following equation (the superscript \(A\) is ignored):
</p>
\begin{equation*}
  \bm{J} = \begin{bmatrix}
    {\hat{\bm{s}}_1}^T & (\bm{b}_1 \times \hat{\bm{s}}_1)^T \\
    {\hat{\bm{s}}_2}^T & (\bm{b}_2 \times \hat{\bm{s}}_2)^T \\
    {\hat{\bm{s}}_3}^T & (\bm{b}_3 \times \hat{\bm{s}}_3)^T \\
    {\hat{\bm{s}}_4}^T & (\bm{b}_4 \times \hat{\bm{s}}_4)^T \\
    {\hat{\bm{s}}_5}^T & (\bm{b}_5 \times \hat{\bm{s}}_5)^T \\
    {\hat{\bm{s}}_6}^T & (\bm{b}_6 \times \hat{\bm{s}}_6)^T
  \end{bmatrix}
\end{equation*}

<p>
The Jacobian matrix \(\bm{J}\) can be computed using the <code>computeJacobian</code> function (accessible <a href="#org2387f19">here</a>).
For instance:
</p>
<div class="org-src-container">
<pre class="src src-matlab">stewart = computeJacobian(stewart);
</pre>
</div>
<p>
This will add three new matrix to the <code>stewart</code> structure:
</p>
<ul class="org-ul">
<li><code>J</code> the Jacobian matrix</li>
<li><code>K</code> the stiffness matrix</li>
<li><code>C</code> the compliance matrix</li>
</ul>
</div>
</div>

<div id="outline-container-org4d71022" class="outline-3">
<h3 id="org4d71022"><span class="section-number-3">1.2</span> Jacobian - Velocity loop closure</h3>
<div class="outline-text-3" id="text-1-2">
<p>
The Jacobian matrix links the input joint rate \(\dot{\bm{\mathcal{L}}} = [ \dot{l}_1, \dot{l}_2, \dot{l}_3, \dot{l}_4, \dot{l}_5, \dot{l}_6 ]^T\) of each strut to the output twist vector of the mobile platform is denoted by \(\dot{\bm{X}} = [^A\bm{v}_p, {}^A\bm{\omega}]^T\):
</p>
\begin{equation*}
  \dot{\bm{\mathcal{L}}} = \bm{J} \dot{\bm{\mathcal{X}}}
\end{equation*}

<p>
The input joint rate \(\dot{\bm{\mathcal{L}}}\) can be measured by taking the derivative of the relative motion sensor in each strut.
The output twist vector can be measured with a &ldquo;Transform Sensor&rdquo; block measuring the relative velocity and relative angular velocity of frame \(\{B\}\) with respect to frame \(\{A\}\).
</p>

<p>
If the Jacobian matrix is inversible, we can also compute \(\dot{\bm{\mathcal{X}}}\) from \(\dot{\bm{\mathcal{L}}}\).
</p>
\begin{equation*}
  \dot{\bm{\mathcal{X}}} = \bm{J}^{-1} \dot{\bm{\mathcal{L}}}
\end{equation*}

<p>
The Jacobian matrix can also be used to approximate forward and inverse kinematics for small displacements.
This is explained in section <a href="#org02628f3">3.3</a>.
</p>
</div>
</div>

<div id="outline-container-org2847e30" class="outline-3">
<h3 id="org2847e30"><span class="section-number-3">1.3</span> Jacobian - Static Force Transformation</h3>
<div class="outline-text-3" id="text-1-3">
<p>
If we note:
</p>
<ul class="org-ul">
<li>\(\bm{\tau} = [\tau_1, \tau_2, \cdots, \tau_6]^T\): vector of actuator forces applied in each strut</li>
<li>\(\bm{\mathcal{F}} = [\bm{f}, \bm{n}]^T\): external force/torque action on the mobile platform at \(\bm{O}_B\)</li>
</ul>

<p>
We find that the transpose of the Jacobian matrix links the two by the following equation:
</p>
\begin{equation*}
  \bm{\mathcal{F}} = \bm{J}^T \bm{\tau}
\end{equation*}

<p>
If the Jacobian matrix is inversible, we also have the following relation:
</p>
\begin{equation*}
  \bm{\tau} = \bm{J}^{-T} \bm{\mathcal{F}}
\end{equation*}
</div>
</div>
</div>

<div id="outline-container-org87bfd11" class="outline-2">
<h2 id="org87bfd11"><span class="section-number-2">2</span> Stiffness Analysis</h2>
<div class="outline-text-2" id="text-2">
<p>
<a id="orgf9e4f1a"></a>
</p>
<p>
Here, we focus on the deflections of the manipulator moving platform that are the result of the external applied wrench to the mobile platform.
The amount of these deflections are a function of the applied wrench as well as the manipulator <b>structural stiffness</b>.
</p>
</div>
<div id="outline-container-orgb1956e6" class="outline-3">
<h3 id="orgb1956e6"><span class="section-number-3">2.1</span> Computation of the Stiffness and Compliance Matrix</h3>
<div class="outline-text-3" id="text-2-1">
<p>
As explain in <a href="stewart-architecture.html">this</a> document, each Actuator is modeled by 3 elements in parallel:
</p>
<ul class="org-ul">
<li>A spring with a stiffness \(k_{i}\)</li>
<li>A dashpot with a damping \(c_{i}\)</li>
<li>A force source \(\tau_i\)</li>
</ul>

<p>
The stiffness of the actuator \(k_i\) links the applied actuator force \(\delta \tau_i\) and the corresponding small deflection \(\delta l_i\):
</p>
\begin{equation*}
  \tau_i = k_i \delta l_i, \quad i = 1,\ \dots,\ 6
\end{equation*}
<p>
If we combine these 6 relations:
</p>
\begin{equation*}
  \bm{\tau} = \mathcal{K} \delta \bm{\mathcal{L}} \quad \mathcal{K} = \text{diag}\left[ k_1,\ \dots,\ k_6 \right]
\end{equation*}

<p>
Substituting \(\bm{\tau} = \bm{J}^{-T} \bm{\mathcal{F}}\) and \(\delta \bm{\mathcal{L}} = \bm{J} \cdot \delta \bm{\mathcal{X}}\) gives
</p>
\begin{equation*}
  \bm{\mathcal{F}} = \bm{J}^T \mathcal{K} \bm{J} \cdot \delta \bm{\mathcal{X}}
\end{equation*}
<p>
And then we identify the stiffness matrix \(\bm{K}\):
</p>
\begin{equation*}
  \bm{K} = \bm{J}^T \mathcal{K} \bm{J}
\end{equation*}

<p>
If the stiffness matrix \(\bm{K}\) is inversible, the <b>compliance matrix</b> of the manipulator is defined as
</p>
\begin{equation*}
  \bm{C} = \bm{K}^{-1} = (\bm{J}^T \mathcal{K} \bm{J})^{-1}
\end{equation*}

<p>
The compliance matrix of a manipulator shows the mapping of the moving platform wrench applied at \(\bm{O}_B\) to its small deflection by
</p>
\begin{equation*}
  \delta \bm{\mathcal{X}} = \bm{C} \cdot \bm{\mathcal{F}}
\end{equation*}

<p>
The stiffness and compliance matrices are computed using the <code>computeJacobian</code> function (accessible <a href="#org2387f19">here</a>).
</p>
</div>
</div>
</div>

<div id="outline-container-org5718735" class="outline-2">
<h2 id="org5718735"><span class="section-number-2">3</span> Forward and Inverse Kinematics</h2>
<div class="outline-text-2" id="text-3">
<p>
<a id="orgca82bb8"></a>
</p>
</div>
<div id="outline-container-orgebda1d9" class="outline-3">
<h3 id="orgebda1d9"><span class="section-number-3">3.1</span> Inverse Kinematics</h3>
<div class="outline-text-3" id="text-3-1">
<p>
<a id="org2f224fc"></a>
</p>

<blockquote>
<p>
For <b>inverse kinematic analysis</b>, it is assumed that the position \({}^A\bm{P}\) and orientation of the moving platform \({}^A\bm{R}_B\)  are given and the problem is to obtain the joint variables \(\bm{\mathcal{L}} = \left[ l_1, l_2, l_3, l_4, l_5, l_6 \right]^T\).
</p>
</blockquote>

<p>
This problem can be easily solved using the loop closures.
</p>

<p>
The obtain joint variables are:
</p>
\begin{equation*}
  \begin{aligned}
    l_i = &\Big[ {}^A\bm{P}^T {}^A\bm{P} + {}^B\bm{b}_i^T {}^B\bm{b}_i + {}^A\bm{a}_i^T {}^A\bm{a}_i - 2 {}^A\bm{P}^T {}^A\bm{a}_i + \dots\\
          &2 {}^A\bm{P}^T \left[{}^A\bm{R}_B {}^B\bm{b}_i\right] - 2 \left[{}^A\bm{R}_B {}^B\bm{b}_i\right]^T {}^A\bm{a}_i \Big]^{1/2}
  \end{aligned}
\end{equation*}

<p>
If the position and orientation of the platform lie in the feasible workspace, the solution is unique.
Otherwise, the solution gives complex numbers.
</p>

<p>
This inverse kinematic solution can be obtained using the function <code>inverseKinematics</code> (described <a href="#orgb8859d7">here</a>).
</p>
</div>
</div>

<div id="outline-container-org1795522" class="outline-3">
<h3 id="org1795522"><span class="section-number-3">3.2</span> Forward Kinematics</h3>
<div class="outline-text-3" id="text-3-2">
<p>
<a id="orgf1db8ea"></a>
</p>

<blockquote>
<p>
In <b>forward kinematic analysis</b>, it is assumed that the vector of limb lengths \(\bm{L}\) is given and the problem is to find the position \({}^A\bm{P}\) and the orientation \({}^A\bm{R}_B\).
</p>
</blockquote>

<p>
This is a difficult problem that requires to solve nonlinear equations.
</p>

<p>
In a next section, an approximate solution of the forward kinematics problem is proposed for small displacements.
</p>
</div>
</div>

<div id="outline-container-org5a3ce80" class="outline-3">
<h3 id="org5a3ce80"><span class="section-number-3">3.3</span> Approximate solution of the Forward and Inverse Kinematic problem for small displacement using the Jacobian matrix</h3>
<div class="outline-text-3" id="text-3-3">
<p>
<a id="org02628f3"></a>
</p>

<p>
For small displacements mobile platform displacement \(\delta \bm{\mathcal{X}} = [\delta x, \delta y, \delta z, \delta \theta_x, \delta \theta_y, \delta \theta_z ]^T\) around \(\bm{\mathcal{X}}_0\), the associated joint displacement can be computed using the Jacobian (approximate solution of the inverse kinematic problem):
</p>
\begin{equation*}
  \delta\bm{\mathcal{L}} = \bm{J} \delta\bm{\mathcal{X}}
\end{equation*}

<p>
Similarly, for small joint displacements \(\delta\bm{\mathcal{L}} = [ \delta l_1,\ \dots,\ \delta l_6 ]^T\) around \(\bm{\mathcal{L}}_0\), it is possible to find the induced small displacement of the mobile platform (approximate solution of the forward kinematic problem):
</p>
\begin{equation*}
  \delta\bm{\mathcal{X}} = \bm{J}^{-1} \delta\bm{\mathcal{L}}
\end{equation*}

<p>
These two relations solve the forward and inverse kinematic problems for small displacement in a <b>approximate</b> way.
As the inverse kinematic can be easily solved exactly this is not much useful, however, as the forward kinematic problem is difficult to solve, this approximation can be very useful for small displacements.
</p>

<p>
The function <code>forwardKinematicsApprox</code> (described <a href="#orgdb31434">here</a>) can be used to solve the forward kinematic problem using the Jacobian matrix.
</p>
</div>
</div>
</div>

<div id="outline-container-org86b4b35" class="outline-2">
<h2 id="org86b4b35"><span class="section-number-2">4</span> Estimation of the range validity of the approximate inverse kinematics</h2>
<div class="outline-text-2" id="text-4">
<p>
<a id="org7d1d866"></a>
</p>

<div class="note">
<p>
The Matlab script corresponding to this section is accessible <a href="../matlab/kinematic_study_approximation_validity.m">here</a>.
</p>

<p>
To run the script, open the Simulink Project, and type <code>run kinematic_study_approximation_validity.m</code>.
</p>

</div>
<p>
As we know how to exactly solve the Inverse kinematic problem, we can compare the exact solution with the approximate solution using the Jacobian matrix.
For small displacements, the approximate solution is expected to work well.
We would like here to determine up to what displacement this approximation can be considered as correct.
</p>

<p>
Then, we can determine the range for which the approximate inverse kinematic is valid.
This will also gives us the range for which the approximate forward kinematic is valid.
</p>
</div>

<div id="outline-container-orga78aa66" class="outline-3">
<h3 id="orga78aa66"><span class="section-number-3">4.1</span> Stewart architecture definition</h3>
<div class="outline-text-3" id="text-4-1">
<p>
We first define some general Stewart architecture.
</p>
<div class="org-src-container">
<pre class="src src-matlab">stewart = initializeStewartPlatform();
stewart = initializeFramesPositions(stewart, 'H', 90e-3, 'MO_B', 45e-3);
stewart = generateGeneralConfiguration(stewart);
stewart = computeJointsPose(stewart);
stewart = initializeStewartPose(stewart);
stewart = initializeCylindricalPlatforms(stewart);
stewart = initializeCylindricalStruts(stewart);
stewart = initializeStrutDynamics(stewart);
stewart = initializeJointDynamics(stewart);
stewart = computeJacobian(stewart);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd83ccf3" class="outline-3">
<h3 id="orgd83ccf3"><span class="section-number-3">4.2</span> Comparison for &ldquo;pure&rdquo; translations</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Let&rsquo;s first compare the perfect and approximate solution of the inverse for pure \(x\) translations.
</p>

<p>
We compute the approximate and exact required strut stroke to have the wanted mobile platform \(x\) displacement.
The estimate required strut stroke for both the approximate and exact solutions are shown in Figure <a href="#org5996f21">1</a>.
The relative strut length displacement is shown in Figure <a href="#org02d8e34">2</a>.
</p>
<div class="org-src-container">
<pre class="src src-matlab">Xrs = logspace(-6, -1, 100); % Wanted X translation of the mobile platform [m]

Ls_approx = zeros(6, length(Xrs));
Ls_exact = zeros(6, length(Xrs));

for i = 1:length(Xrs)
  Xr = Xrs(i);
  L_approx(:, i) = stewart.kinematics.J*[Xr; 0; 0; 0; 0; 0;];
  [~, L_exact(:, i)] = inverseKinematics(stewart, 'AP', [Xr; 0; 0]);
end
</pre>
</div>


<div id="org5996f21" class="figure">
<p><img src="figs/inverse_kinematics_approx_validity_x_translation.png" alt="inverse_kinematics_approx_validity_x_translation.png" />
</p>
<p><span class="figure-number">Figure 1: </span>Comparison of the Approximate solution and True solution for the Inverse kinematic problem (<a href="./figs/inverse_kinematics_approx_validity_x_translation.png">png</a>, <a href="./figs/inverse_kinematics_approx_validity_x_translation.pdf">pdf</a>)</p>
</div>


<div id="org02d8e34" class="figure">
<p><img src="figs/inverse_kinematics_approx_validity_x_translation_relative.png" alt="inverse_kinematics_approx_validity_x_translation_relative.png" />
</p>
<p><span class="figure-number">Figure 2: </span>Relative length error by using the Approximate solution of the Inverse kinematic problem (<a href="./figs/inverse_kinematics_approx_validity_x_translation_relative.png">png</a>, <a href="./figs/inverse_kinematics_approx_validity_x_translation_relative.pdf">pdf</a>)</p>
</div>
</div>
</div>

<div id="outline-container-org4871c83" class="outline-3">
<h3 id="org4871c83"><span class="section-number-3">4.3</span> Conclusion</h3>
<div class="outline-text-3" id="text-4-3">
<div class="important">
<p>
For small wanted displacements (up to \(\approx 1\%\) of the size of the Hexapod), the approximate inverse kinematic solution using the Jacobian matrix is quite correct.
</p>

</div>
</div>
</div>
</div>

<div id="outline-container-org63255f9" class="outline-2">
<h2 id="org63255f9"><span class="section-number-2">5</span> Estimated required actuator stroke from specified platform mobility</h2>
<div class="outline-text-2" id="text-5">
<p>
<a id="org1f540fa"></a>
</p>

<div class="note">
<p>
The Matlab script corresponding to this section is accessible <a href="../matlab/kinematic_study_required_actuator_stroke.m">here</a>.
</p>

<p>
To run the script, open the Simulink Project, and type <code>run kinematic_study_required_actuator_stroke.m</code>.
</p>

</div>
<p>
Let&rsquo;s say one want to design a Stewart platform with some specified mobility (position and orientation).
One may want to determine the required actuator stroke required to obtain the specified mobility.
This is what is analyzed in this section.
</p>
</div>

<div id="outline-container-orgadaa219" class="outline-3">
<h3 id="orgadaa219"><span class="section-number-3">5.1</span> Stewart architecture definition</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Let&rsquo;s first define the Stewart platform architecture that we want to study.
</p>
<div class="org-src-container">
<pre class="src src-matlab">stewart = initializeStewartPlatform();
stewart = initializeFramesPositions(stewart, 'H', 90e-3, 'MO_B', 45e-3);
stewart = generateGeneralConfiguration(stewart);
stewart = computeJointsPose(stewart);
stewart = initializeStewartPose(stewart);
stewart = initializeCylindricalPlatforms(stewart);
stewart = initializeCylindricalStruts(stewart);
stewart = initializeStrutDynamics(stewart);
stewart = initializeJointDynamics(stewart);
stewart = computeJacobian(stewart);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgde50dd3" class="outline-3">
<h3 id="orgde50dd3"><span class="section-number-3">5.2</span> Wanted translations and rotations</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Let&rsquo;s now define the wanted extreme translations and rotations.
</p>
<div class="org-src-container">
<pre class="src src-matlab">Tx_max = 50e-6; % Translation [m]
Ty_max = 50e-6; % Translation [m]
Tz_max = 50e-6; % Translation [m]
Rx_max = 30e-6; % Rotation [rad]
Ry_max = 30e-6; % Rotation [rad]
Rz_max = 0;     % Rotation [rad]
</pre>
</div>
</div>
</div>

<div id="outline-container-org24e45ca" class="outline-3">
<h3 id="org24e45ca"><span class="section-number-3">5.3</span> Needed stroke for &ldquo;pure&rdquo; rotations or translations</h3>
<div class="outline-text-3" id="text-5-3">
<p>
As a first estimation, we estimate the needed actuator stroke for &ldquo;pure&rdquo; rotations and translation.
We do that using either the Inverse Kinematic solution or the Jacobian matrix as an approximation.
</p>

<div class="org-src-container">
<pre class="src src-matlab">LTx = stewart.kinematics.J*[Tx_max 0 0 0 0 0]';
LTy = stewart.kinematics.J*[0 Ty_max 0 0 0 0]';
LTz = stewart.kinematics.J*[0 0 Tz_max 0 0 0]';
LRx = stewart.kinematics.J*[0 0 0 Rx_max 0 0]';
LRy = stewart.kinematics.J*[0 0 0 0 Ry_max 0]';
LRz = stewart.kinematics.J*[0 0 0 0 0 Rz_max]';
</pre>
</div>

<p>
The obtain required stroke is:
</p>
<pre class="example">
From -3.8e-05[m] to 3.8e-05[m]: Total stroke = 76.1[um]
</pre>


<p>
This is surely a low estimation of the required stroke.
</p>
</div>
</div>

<div id="outline-container-orgf6ba90c" class="outline-3">
<h3 id="orgf6ba90c"><span class="section-number-3">5.4</span> Needed stroke for &ldquo;combined&rdquo; rotations or translations</h3>
<div class="outline-text-3" id="text-5-4">
<p>
We know would like to have a more precise estimation.
</p>

<p>
To do so, we may estimate the required actuator stroke for all possible combination of translation and rotation.
</p>

<p>
Let&rsquo;s first generate all the possible combination of maximum translation and rotations.
</p>
<div class="org-src-container">
<pre class="src src-matlab">Ps = [2*(dec2bin(0:5^2-1,5)-'0')-1, zeros(5^2, 1)].*[Tx_max Ty_max Tz_max Rx_max Ry_max Rz_max];
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right"><b>Tx [m]</b></th>
<th scope="col" class="org-right"><b>Ty [m]</b></th>
<th scope="col" class="org-right"><b>Tz [m]</b></th>
<th scope="col" class="org-right"><b>Rx [rad]</b></th>
<th scope="col" class="org-right"><b>Ry [rad]</b></th>
<th scope="col" class="org-right"><b>Rz [rad]</b></th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">-5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>

<tr>
<td class="org-right">-5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>

<tr>
<td class="org-right">-5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">3.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>

<tr>
<td class="org-right">-5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">3.0e-05</td>
<td class="org-right">3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>

<tr>
<td class="org-right">-5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">5.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>

<tr>
<td class="org-right">-5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">5.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>

<tr>
<td class="org-right">-5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">5.0e-05</td>
<td class="org-right">3.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>

<tr>
<td class="org-right">-5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">5.0e-05</td>
<td class="org-right">3.0e-05</td>
<td class="org-right">3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>

<tr>
<td class="org-right">-5.0e-05</td>
<td class="org-right">5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>

<tr>
<td class="org-right">-5.0e-05</td>
<td class="org-right">5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>

<tr>
<td class="org-right">-5.0e-05</td>
<td class="org-right">5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">3.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>

<tr>
<td class="org-right">-5.0e-05</td>
<td class="org-right">5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">3.0e-05</td>
<td class="org-right">3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>

<tr>
<td class="org-right">-5.0e-05</td>
<td class="org-right">5.0e-05</td>
<td class="org-right">5.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>

<tr>
<td class="org-right">-5.0e-05</td>
<td class="org-right">5.0e-05</td>
<td class="org-right">5.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>

<tr>
<td class="org-right">-5.0e-05</td>
<td class="org-right">5.0e-05</td>
<td class="org-right">5.0e-05</td>
<td class="org-right">3.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>

<tr>
<td class="org-right">-5.0e-05</td>
<td class="org-right">5.0e-05</td>
<td class="org-right">5.0e-05</td>
<td class="org-right">3.0e-05</td>
<td class="org-right">3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>

<tr>
<td class="org-right">5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>

<tr>
<td class="org-right">5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>

<tr>
<td class="org-right">5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">3.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>

<tr>
<td class="org-right">5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">3.0e-05</td>
<td class="org-right">3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>

<tr>
<td class="org-right">5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">5.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>

<tr>
<td class="org-right">5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">5.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>

<tr>
<td class="org-right">5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">5.0e-05</td>
<td class="org-right">3.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>

<tr>
<td class="org-right">5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">5.0e-05</td>
<td class="org-right">3.0e-05</td>
<td class="org-right">3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>

<tr>
<td class="org-right">5.0e-05</td>
<td class="org-right">5.0e-05</td>
<td class="org-right">-5.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">-3.0e-05</td>
<td class="org-right">0.0e+00</td>
</tr>
</tbody>
</table>

<p>
For all possible combination, we compute the required actuator stroke using the inverse kinematic solution.
</p>
<div class="org-src-container">
<pre class="src src-matlab">L_min = 0;
L_max = 0;

for i = 1:size(Ps,1)
  Rx = [1 0        0;
        0 cos(Ps(i, 4)) -sin(Ps(i, 4));
        0 sin(Ps(i, 4))  cos(Ps(i, 4))];

  Ry = [ cos(Ps(i, 5)) 0 sin(Ps(i, 5));
        0        1 0;
        -sin(Ps(i, 5)) 0 cos(Ps(i, 5))];

  Rz = [cos(Ps(i, 6)) -sin(Ps(i, 6)) 0;
        sin(Ps(i, 6))  cos(Ps(i, 6)) 0;
        0        0       1];

  ARB = Rz*Ry*Rx;
  [~, Ls] = inverseKinematics(stewart, 'AP', Ps(i, 1:3)', 'ARB', ARB);

  if min(Ls) &lt; L_min
    L_min = min(Ls)
  end
  if max(Ls) &gt; L_max
    L_max = max(Ls)
  end
end
</pre>
</div>

<p>
We obtain the required actuator stroke:
</p>
<pre class="example">
From -8.9e-05[m] to 8.9e-05[m]: Total stroke = 177.2[um]
</pre>


<p>
This is probably a much realistic estimation of the required actuator stroke.
</p>
</div>
</div>
</div>

<div id="outline-container-orgbbbf7b3" class="outline-2">
<h2 id="orgbbbf7b3"><span class="section-number-2">6</span> Estimated platform mobility from specified actuator stroke</h2>
<div class="outline-text-2" id="text-6">
<p>
<a id="org9e16ee3"></a>
</p>

<div class="note">
<p>
The Matlab script corresponding to this section is accessible <a href="../matlab/kinematic_study_mobility.m">here</a>.
</p>

<p>
To run the script, open the Simulink Project, and type <code>run kinematic_study_mobility.m</code>.
</p>

</div>
<p>
Here, from some value of the actuator stroke, we would like to estimate the mobility of the Stewart platform.
</p>

<p>
As explained in section <a href="#orgca82bb8">3</a>, the forward kinematic problem of the Stewart platform is quite difficult to solve.
However, for small displacements, we can use the Jacobian as an approximate solution.
</p>
</div>

<div id="outline-container-org6a6a5df" class="outline-3">
<h3 id="org6a6a5df"><span class="section-number-3">6.1</span> Stewart architecture definition</h3>
<div class="outline-text-3" id="text-6-1">
<p>
Let&rsquo;s first define the Stewart platform architecture that we want to study.
</p>
<div class="org-src-container">
<pre class="src src-matlab">stewart = initializeStewartPlatform();
stewart = initializeFramesPositions(stewart, 'H', 90e-3, 'MO_B', 45e-3);
stewart = generateGeneralConfiguration(stewart);
stewart = computeJointsPose(stewart);
stewart = initializeStewartPose(stewart);
stewart = initializeCylindricalPlatforms(stewart);
stewart = initializeCylindricalStruts(stewart);
stewart = initializeStrutDynamics(stewart);
stewart = initializeJointDynamics(stewart);
stewart = computeJacobian(stewart);
</pre>
</div>

<p>
Let&rsquo;s now define the actuator stroke.
</p>
<div class="org-src-container">
<pre class="src src-matlab">L_min = -50e-6; % [m]
L_max =  50e-6; % [m]
</pre>
</div>
</div>
</div>

<div id="outline-container-org2c6819e" class="outline-3">
<h3 id="org2c6819e"><span class="section-number-3">6.2</span> Pure translations</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Let&rsquo;s first estimate the mobility in translation when the orientation of the Stewart platform stays the same.
</p>

<p>
As shown previously, for such small stroke, we can use the approximate Forward Dynamics solution using the Jacobian matrix:
</p>
\begin{equation*}
  \delta\bm{\mathcal{L}} = \bm{J} \delta\bm{\mathcal{X}}
\end{equation*}

<p>
To obtain the mobility &ldquo;volume&rdquo; attainable by the Stewart platform when it&rsquo;s orientation is set to zero, we use the spherical coordinate \((r, \theta, \phi)\).
</p>

<p>
For each possible value of \((\theta, \phi)\), we compute the maximum radius \(r\) attainable with the constraint that the stroke of each actuator should be between <code>L_min</code> and <code>L_max</code>.
</p>
<div class="org-src-container">
<pre class="src src-matlab">thetas = linspace(0, pi, 50);
phis = linspace(0, 2*pi, 50);
rs = zeros(length(thetas), length(phis));

for i = 1:length(thetas)
  for j = 1:length(phis)
    Tx = sin(thetas(i))*cos(phis(j));
    Ty = sin(thetas(i))*sin(phis(j));
    Tz = cos(thetas(i));

    dL = stewart.kinematics.J*[Tx; Ty; Tz; 0; 0; 0;]; % dL required for 1m displacement in theta/phi direction

    rs(i, j) = max([dL(dL&lt;0)*L_min; dL(dL&gt;0)*L_max]);
  end
end
</pre>
</div>


<p>
Now that we have found the corresponding radius \(r\), we plot the obtained mobility.
We can also approximate the mobility by a sphere with a radius equal to the minimum obtained value of \(r\), this is however a pessimistic estimation of the mobility.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right"><code>L_min</code> [\(\mu m\)]</th>
<th scope="col" class="org-right"><code>L_max</code> [\(\mu m\)]</th>
<th scope="col" class="org-right"><code>R</code> [\(\mu m\)]</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">-50.0</td>
<td class="org-right">50.0</td>
<td class="org-right">31.5</td>
</tr>
</tbody>
</table>


<div id="orgc67ab85" class="figure">
<p><img src="figs/mobility_translations_null_rotation.png" alt="mobility_translations_null_rotation.png" />
</p>
<p><span class="figure-number">Figure 3: </span>Obtain mobility of the Stewart platform for zero rotations (<a href="./figs/mobility_translations_null_rotation.png">png</a>, <a href="./figs/mobility_translations_null_rotation.pdf">pdf</a>)</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgad495dd" class="outline-2">
<h2 id="orgad495dd"><span class="section-number-2">7</span> Estimation of the Joint required Stroke</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-orgae20178" class="outline-3">
<h3 id="orgae20178"><span class="section-number-3">7.1</span> Example of the initialization of a Stewart Platform</h3>
<div class="outline-text-3" id="text-7-1">
<p>
Let&rsquo;s first define the Stewart Platform Geometry.
</p>
<div class="org-src-container">
<pre class="src src-matlab">stewart = initializeStewartPlatform();
stewart = initializeFramesPositions(stewart, 'H', 90e-3, 'MO_B', 150e-3);
stewart = generateGeneralConfiguration(stewart);
stewart = computeJointsPose(stewart);

As_init = stewart.geometry.As;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">Tx_max = 50e-6; % Translation [m]
Ty_max = 50e-6; % Translation [m]
Tz_max = 50e-6; % Translation [m]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">Ps = [2*(dec2bin(0:3^2-2,3)-'0')-1].*[Tx_max Ty_max Tz_max];
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">flex_ang = zeros(size(Ps, 1), 6);

for Ps_i = 1:size(Ps, 1)
    stewart.geometry.FO_M = [0; 0; 90e-3] + Ps(Ps_i, :)';

    stewart = generateGeneralConfiguration(stewart);
    stewart = computeJointsPose(stewart);

    flex_ang(Ps_i, :) = acos(sum(As_init.*stewart.geometry.As));
end
</pre>
</div>

<p>
And the maximum bending of the flexible joints is: (in [mrad])
</p>
<div class="org-src-container">
<pre class="src src-matlab">1e3*max(max(abs(flex_ang)))
</pre>
</div>

<pre class="example">
0.90937
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc4916dc" class="outline-2">
<h2 id="orgc4916dc"><span class="section-number-2">8</span> Functions</h2>
<div class="outline-text-2" id="text-8">
<p>
<a id="orgf9a6042"></a>
</p>
</div>
<div id="outline-container-org26e8b28" class="outline-3">
<h3 id="org26e8b28"><span class="section-number-3">8.1</span> <code>computeJacobian</code>: Compute the Jacobian Matrix</h3>
<div class="outline-text-3" id="text-8-1">
<p>
<a id="org2387f19"></a>
</p>

<p>
This Matlab function is accessible <a href="../src/computeJacobian.m">here</a>.
</p>
</div>

<div id="outline-container-orgcde905e" class="outline-4">
<h4 id="orgcde905e">Function description</h4>
<div class="outline-text-4" id="text-orgcde905e">
<div class="org-src-container">
<pre class="src src-matlab">function [stewart] = computeJacobian(stewart)
% computeJacobian -
%
% Syntax: [stewart] = computeJacobian(stewart)
%
% Inputs:
%    - stewart - With at least the following fields:
%      - geometry.As [3x6] - The 6 unit vectors for each strut expressed in {A}
%      - geometry.Ab [3x6] - The 6 position of the joints bi expressed in {A}
%      - actuators.K [6x1] - Total stiffness of the actuators
%
% Outputs:
%    - stewart - With the 3 added field:
%        - kinematics.J [6x6] - The Jacobian Matrix
%        - kinematics.K [6x6] - The Stiffness Matrix
%        - kinematics.C [6x6] - The Compliance Matrix
</pre>
</div>
</div>
</div>

<div id="outline-container-org5be121e" class="outline-4">
<h4 id="org5be121e">Check the <code>stewart</code> structure elements</h4>
<div class="outline-text-4" id="text-org5be121e">
<div class="org-src-container">
<pre class="src src-matlab">assert(isfield(stewart.geometry, 'As'),   'stewart.geometry should have attribute As')
As = stewart.geometry.As;

assert(isfield(stewart.geometry, 'Ab'),   'stewart.geometry should have attribute Ab')
Ab = stewart.geometry.Ab;

assert(isfield(stewart.actuators, 'K'),   'stewart.actuators should have attribute K')
Ki = stewart.actuators.K;
</pre>
</div>
</div>
</div>


<div id="outline-container-org0cd57b5" class="outline-4">
<h4 id="org0cd57b5">Compute Jacobian Matrix</h4>
<div class="outline-text-4" id="text-org0cd57b5">
<div class="org-src-container">
<pre class="src src-matlab">J = [As' , cross(Ab, As)'];
</pre>
</div>
</div>
</div>

<div id="outline-container-orge21dcfc" class="outline-4">
<h4 id="orge21dcfc">Compute Stiffness Matrix</h4>
<div class="outline-text-4" id="text-orge21dcfc">
<div class="org-src-container">
<pre class="src src-matlab">K = J'*diag(Ki)*J;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgae76071" class="outline-4">
<h4 id="orgae76071">Compute Compliance Matrix</h4>
<div class="outline-text-4" id="text-orgae76071">
<div class="org-src-container">
<pre class="src src-matlab">C = inv(K);
</pre>
</div>
</div>
</div>

<div id="outline-container-org78f18d7" class="outline-4">
<h4 id="org78f18d7">Populate the <code>stewart</code> structure</h4>
<div class="outline-text-4" id="text-org78f18d7">
<div class="org-src-container">
<pre class="src src-matlab">stewart.kinematics.J = J;
stewart.kinematics.K = K;
stewart.kinematics.C = C;
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgb82066f" class="outline-3">
<h3 id="orgb82066f"><span class="section-number-3">8.2</span> <code>inverseKinematics</code>: Compute Inverse Kinematics</h3>
<div class="outline-text-3" id="text-8-2">
<p>
<a id="orgb8859d7"></a>
</p>

<p>
This Matlab function is accessible <a href="../src/inverseKinematics.m">here</a>.
</p>
</div>

<div id="outline-container-org89930b7" class="outline-4">
<h4 id="org89930b7">Theory</h4>
<div class="outline-text-4" id="text-org89930b7">
<p>
For inverse kinematic analysis, it is assumed that the position \({}^A\bm{P}\) and orientation of the moving platform \({}^A\bm{R}_B\) are given and the problem is to obtain the joint variables, namely, \(\bm{L} = [l_1, l_2, \dots, l_6]^T\).
</p>

<p>
From the geometry of the manipulator, the loop closure for each limb, \(i = 1, 2, \dots, 6\) can be written as
</p>
\begin{align*}
  l_i {}^A\hat{\bm{s}}_i &= {}^A\bm{A} + {}^A\bm{b}_i - {}^A\bm{a}_i \\
                         &= {}^A\bm{A} + {}^A\bm{R}_b {}^B\bm{b}_i - {}^A\bm{a}_i
\end{align*}

<p>
To obtain the length of each actuator and eliminate \(\hat{\bm{s}}_i\), it is sufficient to dot multiply each side by itself:
</p>
\begin{equation}
  l_i^2 \left[ {}^A\hat{\bm{s}}_i^T {}^A\hat{\bm{s}}_i \right] = \left[ {}^A\bm{P} + {}^A\bm{R}_B {}^B\bm{b}_i - {}^A\bm{a}_i \right]^T \left[ {}^A\bm{P} + {}^A\bm{R}_B {}^B\bm{b}_i - {}^A\bm{a}_i \right]
\end{equation}

<p>
Hence, for \(i = 1, 2, \dots, 6\), each limb length can be uniquely determined by:
</p>
\begin{equation}
  l_i = \sqrt{{}^A\bm{P}^T {}^A\bm{P} + {}^B\bm{b}_i^T {}^B\bm{b}_i + {}^A\bm{a}_i^T {}^A\bm{a}_i - 2 {}^A\bm{P}^T {}^A\bm{a}_i + 2 {}^A\bm{P}^T \left[{}^A\bm{R}_B {}^B\bm{b}_i\right] - 2 \left[{}^A\bm{R}_B {}^B\bm{b}_i\right]^T {}^A\bm{a}_i}
\end{equation}

<p>
If the position and orientation of the moving platform lie in the feasible workspace of the manipulator, one unique solution to the limb length is determined by the above equation.
Otherwise, when the limbs&rsquo; lengths derived yield complex numbers, then the position or orientation of the moving platform is not reachable.
</p>
</div>
</div>

<div id="outline-container-orgb66d0e9" class="outline-4">
<h4 id="orgb66d0e9">Function description</h4>
<div class="outline-text-4" id="text-orgb66d0e9">
<div class="org-src-container">
<pre class="src src-matlab">function [Li, dLi] = inverseKinematics(stewart, args)
% inverseKinematics - Compute the needed length of each strut to have the wanted position and orientation of {B} with respect to {A}
%
% Syntax: [stewart] = inverseKinematics(stewart)
%
% Inputs:
%    - stewart - A structure with the following fields
%        - geometry.Aa   [3x6] - The positions ai expressed in {A}
%        - geometry.Bb   [3x6] - The positions bi expressed in {B}
%        - geometry.l    [6x1] - Length of each strut
%    - args - Can have the following fields:
%        - AP   [3x1] - The wanted position of {B} with respect to {A}
%        - ARB  [3x3] - The rotation matrix that gives the wanted orientation of {B} with respect to {A}
%
% Outputs:
%    - Li   [6x1] - The 6 needed length of the struts in [m] to have the wanted pose of {B} w.r.t. {A}
%    - dLi  [6x1] - The 6 needed displacement of the struts from the initial position in [m] to have the wanted pose of {B} w.r.t. {A}
</pre>
</div>
</div>
</div>

<div id="outline-container-org0aeb7ad" class="outline-4">
<h4 id="org0aeb7ad">Optional Parameters</h4>
<div class="outline-text-4" id="text-org0aeb7ad">
<div class="org-src-container">
<pre class="src src-matlab">arguments
    stewart
    args.AP  (3,1) double {mustBeNumeric} = zeros(3,1)
    args.ARB (3,3) double {mustBeNumeric} = eye(3)
end
</pre>
</div>
</div>
</div>

<div id="outline-container-orga54645b" class="outline-4">
<h4 id="orga54645b">Check the <code>stewart</code> structure elements</h4>
<div class="outline-text-4" id="text-orga54645b">
<div class="org-src-container">
<pre class="src src-matlab">assert(isfield(stewart.geometry, 'Aa'),   'stewart.geometry should have attribute Aa')
Aa = stewart.geometry.Aa;

assert(isfield(stewart.geometry, 'Bb'),   'stewart.geometry should have attribute Bb')
Bb = stewart.geometry.Bb;

assert(isfield(stewart.geometry, 'l'),   'stewart.geometry should have attribute l')
l = stewart.geometry.l;
</pre>
</div>
</div>
</div>


<div id="outline-container-org0d64c23" class="outline-4">
<h4 id="org0d64c23">Compute</h4>
<div class="outline-text-4" id="text-org0d64c23">
<div class="org-src-container">
<pre class="src src-matlab">Li = sqrt(args.AP'*args.AP + diag(Bb'*Bb) + diag(Aa'*Aa) - (2*args.AP'*Aa)' + (2*args.AP'*(args.ARB*Bb))' - diag(2*(args.ARB*Bb)'*Aa));
</pre>
</div>

<div class="org-src-container">
<pre class="src src-matlab">dLi = Li-l;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf5d8f0b" class="outline-3">
<h3 id="orgf5d8f0b"><span class="section-number-3">8.3</span> <code>forwardKinematicsApprox</code>: Compute the Approximate Forward Kinematics</h3>
<div class="outline-text-3" id="text-8-3">
<p>
<a id="orgdb31434"></a>
</p>

<p>
This Matlab function is accessible <a href="../src/forwardKinematicsApprox.m">here</a>.
</p>
</div>

<div id="outline-container-orgc074bc3" class="outline-4">
<h4 id="orgc074bc3">Function description</h4>
<div class="outline-text-4" id="text-orgc074bc3">
<div class="org-src-container">
<pre class="src src-matlab">function [P, R] = forwardKinematicsApprox(stewart, args)
% forwardKinematicsApprox - Computed the approximate pose of {B} with respect to {A} from the length of each strut and using
%                           the Jacobian Matrix
%
% Syntax: [P, R] = forwardKinematicsApprox(stewart, args)
%
% Inputs:
%    - stewart - A structure with the following fields
%        - kinematics.J  [6x6] - The Jacobian Matrix
%    - args - Can have the following fields:
%        - dL [6x1] - Displacement of each strut [m]
%
% Outputs:
%    - P  [3x1] - The estimated position of {B} with respect to {A}
%    - R  [3x3] - The estimated rotation matrix that gives the orientation of {B} with respect to {A}
</pre>
</div>
</div>
</div>

<div id="outline-container-org9a855b1" class="outline-4">
<h4 id="org9a855b1">Optional Parameters</h4>
<div class="outline-text-4" id="text-org9a855b1">
<div class="org-src-container">
<pre class="src src-matlab">arguments
    stewart
    args.dL (6,1) double {mustBeNumeric} = zeros(6,1)
end
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdc0187a" class="outline-4">
<h4 id="orgdc0187a">Check the <code>stewart</code> structure elements</h4>
<div class="outline-text-4" id="text-orgdc0187a">
<div class="org-src-container">
<pre class="src src-matlab">assert(isfield(stewart.kinematics, 'J'),   'stewart.kinematics should have attribute J')
J = stewart.kinematics.J;
</pre>
</div>
</div>
</div>

<div id="outline-container-orge5ade24" class="outline-4">
<h4 id="orge5ade24">Computation</h4>
<div class="outline-text-4" id="text-orge5ade24">
<p>
From a small displacement of each strut \(d\bm{\mathcal{L}}\), we can compute the
position and orientation of {B} with respect to {A} using the following formula:
\[ d \bm{\mathcal{X}} = \bm{J}^{-1} d\bm{\mathcal{L}} \]
</p>
<div class="org-src-container">
<pre class="src src-matlab">X = J\args.dL;
</pre>
</div>

<p>
The position vector corresponds to the first 3 elements.
</p>
<div class="org-src-container">
<pre class="src src-matlab">P = X(1:3);
</pre>
</div>

<p>
The next 3 elements are the orientation of {B} with respect to {A} expressed
using the screw axis.
</p>
<div class="org-src-container">
<pre class="src src-matlab">theta = norm(X(4:6));
s = X(4:6)/theta;
</pre>
</div>

<p>
We then compute the corresponding rotation matrix.
</p>
<div class="org-src-container">
<pre class="src src-matlab">R = [s(1)^2*(1-cos(theta)) + cos(theta) ,        s(1)*s(2)*(1-cos(theta)) - s(3)*sin(theta), s(1)*s(3)*(1-cos(theta)) + s(2)*sin(theta);
     s(2)*s(1)*(1-cos(theta)) + s(3)*sin(theta), s(2)^2*(1-cos(theta)) + cos(theta),         s(2)*s(3)*(1-cos(theta)) - s(1)*sin(theta);
     s(3)*s(1)*(1-cos(theta)) - s(2)*sin(theta), s(3)*s(2)*(1-cos(theta)) + s(1)*sin(theta), s(3)^2*(1-cos(theta)) + cos(theta)];
</pre>
</div>
</div>
</div>
</div>
</div>

<p>

</p>

<style>.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}</style><h2 class='citeproc-org-bib-h2'>Bibliography</h2>
<div class="csl-bib-body">
  <div class="csl-entry"><a name="citeproc_bib_item_1"></a>Taghirad, Hamid. 2013. <i>Parallel Robots : Mechanics and Control</i>. Boca Raton, FL: CRC Press.</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Dehaeze Thomas</p>
<p class="date">Created: 2020-08-05 mer. 13:27</p>
</div>
</body>
</html>
